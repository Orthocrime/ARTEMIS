#ARTEMĪDA, izstrādes versija

import sys
from PyQt5.QtWidgets import (QApplication, QMainWindow, QFileDialog, QMessageBox, QWidget, QVBoxLayout,
                             QTableWidget, QTableWidgetItem, QHeaderView, QAction, QTabWidget, QDialog, 
                             QTextEdit, QLineEdit, QMenu, QLabel,QStyledItemDelegate, QInputDialog)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QTextOption
import pandas as pd
from pandas import ExcelWriter
import numpy as np
import re

class WordWrapDelegate(QStyledItemDelegate):
    def paint(self, painter, option, index):
        option.wrapMode = QTextOption.WordWrap
        super().paint(painter, option, index)

class ResizableTable(QTableWidget):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.adjustRowHeights()

    def adjustRowHeights(self):
        for row in range(self.rowCount()):
            self.resizeRowToContents(row)

class ExtendedTableWidgetItem(QTableWidgetItem):
    def __init__(self, value):
        super().__init__(value)
        self.original_value = None

class ExcelDatabaseApp(QMainWindow):
    GRUPA_COLUMN_WIDTH = 200  # Example width for the "Grupa" column
    VERTIBA_COLUMN_WIDTH = 300
    def __init__(self):
        super().__init__()
        self.title = 'ARTEMIS; 0.5xxx-0.6000, 18.2.2024.'
        self.status_bar = self.statusBar()
        self.initUI()
        self.df = None
        self.row_mapping = []

    def initUI(self):
        self.setWindowTitle(self.title)
        self.setGeometry(100, 100, 800, 600)
        
        self.sum_label = QLabel("Kopā: 0")
        self.status_bar.addPermanentWidget(self.sum_label)

        mainMenu = self.menuBar()
        fileMenu = mainMenu.addMenu('Vispārējā izvēlne')
      
        openAction = QAction('Atvērt excel failu', self)
        openAction.triggered.connect(self.load_excel_file)
        fileMenu.addAction(openAction)
        
        submenu = fileMenu.addMenu('Citas opcijas')

        newTextWindowAction = QAction('Par programmu', self)
        newTextWindowAction.triggered.connect(self.openNewTextWindow)
        submenu.addAction(newTextWindowAction)

        newTextWindowAction2 = QAction('Kā lietot', self)
        newTextWindowAction2.triggered.connect(self.openNewTextWindow2)
        submenu.addAction(newTextWindowAction2)

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout()
        self.central_widget.setLayout(self.layout)

        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("Meklēt visās darba grāmatās...")
        self.search_bar.textChanged.connect(self.search_tables)
        self.layout.addWidget(self.search_bar)

        self.tabs = QTabWidget()
        self.layout.addWidget(self.tabs)
        
    def edit_row_data(self, row, table):
        row_data = [table.item(row, col).text() if table.item(row, col) is not None else "" for col in range(table.columnCount())]
        first_row_data = [table.item(0, col).text() if table.item(0, col) is not None else "" for col in range(table.columnCount())]
        dialog = RowEditDialog(row_data, first_row_data, self)

        if dialog.exec_() == QDialog.Accepted:
            edited_data = dialog.get_row_data()
            for col, value in enumerate(edited_data):
                table.item(row, col).setText(value)
                table.item(row, col).setFlags(table.item(row, col).flags() & ~Qt.ItemIsEditable)

    def revert_last_edited_cell_to_readonly(self):
        if hasattr(self, 'last_edited_item') and self.last_edited_item:
            self.last_edited_item.setFlags(self.last_edited_item.flags() & ~Qt.ItemIsEditable)
            self.last_edited_item = None

    def openNewTextWindow(self):
        self.textWindow = QDialog(self)
        self.textWindow.setWindowTitle("Par programmu")
        self.textWindow.resize(400, 300)  
        layout = QVBoxLayout()
        self.textWindow.setLayout(layout)

        textEdit = QTextEdit()
        textEdit.setText("Excel failos esošo datu analīzes rīks, izstrādājis Otto Rostoks, versija 00.0307; ARTEMIS; izmantotās metodes, rīki: PYQT/PYTHON, PANDAS, HTML")  # You can set any default text or make it dynamic
        layout.addWidget(textEdit)

        self.textWindow.exec_() 

    def openNewTextWindow2(self):
        self.textWindow = QDialog(self)
        self.textWindow.setWindowTitle("")
        self.textWindow.resize(400, 300)  
        layout = QVBoxLayout()
        self.textWindow.setLayout(layout)

        textEdit = QTextEdit()
        textEdit.setText("Kā izmantot: izvēlieties izvēlni 'Atvērt excel failu' <šobrīd plānots nākotnes versijās sasaistīt ar konkrētu pakārtoto excel failu>, pēc kā ir iespējams failu pārmeklēt pēc jebkāda teksta, tā daļas, skaitļa vai cipara, iespējams iegūt apkopotus datus, kas saistīti vienā līnijā ar izvēlēto šūnu. Iespēja labot excel failu tieši no datubāzes šobrīd izstrādē. Izdotās informācijas kvalitāte ir tiešā veidā saistīta ar pakārtotajā excel failā ievadītās informācijas sistemātisku.")  # You can set any default text or make it dynamic
        layout.addWidget(textEdit)

        self.textWindow.exec_()

    def load_excel_file(self, filePath):
        options = QFileDialog.Options()
        filePath, _ = QFileDialog.getOpenFileName(self, "Open Excel File", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
        if filePath:
            self.currentFilePath = filePath
            self.dataFrames = {}
            xls = pd.ExcelFile(filePath)
            for sheet_name in xls.sheet_names:
                df = pd.read_excel(filePath, sheet_name=sheet_name)
                df = self.clean_data(df)
                self.dataFrames[sheet_name] = df
                self.add_sheet_tab(df, sheet_name)

    def clean_data(self, df):
        
        
        def process_element(x):
            if isinstance(x, str):
                return x.strip()
            elif isinstance(x, float) and x.is_integer():
                return int(x)  # This converts floats with .0 to integers
            elif isinstance(x, float):
                return round(x, 2)  # Rounds floats to 2 decimal places
            return x

        df = df.applymap(process_element)
        df.replace("", np.nan, inplace=True)
        df.dropna(how='all', inplace=True)

        df.reset_index(drop=True, inplace=True)

        return df
    
    def sum_values_in_cell(cell):
        parts = re.split(r'[\n\s]+', cell_content)
        numeric_parts = [float(part.replace(',', '.')) for part in parts if part.replace(',', '.').replace('.', '', 1).isdigit()]
        return sum(numeric_parts)
        
       

    def add_sheet_tab(self, df, sheet_name):
        if df.shape[0] > 0:
        # Update row mapping for the current sheet's DataFrame
            self.row_mapping = list(range(df.shape[0]))
        else:
        # Handle the case where the DataFrame is empty
            print(f"DataFrame for sheet '{sheet_name}' is empty.")
            return
        
        table = ResizableTable()
        
        tab_widget = QWidget()
        tab_layout = QVBoxLayout()
        tab_widget.setLayout(tab_layout)

        table = CustomTableWidget()
        table.itemSelectionChanged.connect(self.revert_last_edited_cell_to_readonly)
        table.cellChanged.connect(self.cell_content_changed)
        table.itemSelectionChanged.connect(self.update_sum_display)
        table.setColumnCount(len(df.columns))
        table.setRowCount(len(df.index))
        table.setHorizontalHeaderLabels(df.columns)
        table.setSelectionMode(QTableWidget.MultiSelection)
        table.setSelectionBehavior(QTableWidget.SelectItems)
        table.setContextMenuPolicy(Qt.CustomContextMenu)
        table.customContextMenuRequested.connect(self.show_context_menu)
        table.setContextMenuPolicy(Qt.CustomContextMenu)
        table.customContextMenuRequested.connect(self.show_context_menu)

        self.row_mapping = list(range(df.shape[0]))

        char_width = table.fontMetrics().width('0')
        for col in range(table.columnCount()):
            table.setColumnWidth(col, char_width * 10)

        for i in range(df.shape[0]):  # Iterating over each row in the DataFrame
            for j in range(df.shape[1]):  # Iterating over each column in the row
            # Convert the DataFrame value at row i, column j to a string
                content = str(df.iloc[i, j])
                item = ExtendedTableWidgetItem(content)

        for i in range(len(df.index)):
            for j in range(len(df.columns)):
                content = str(df.iloc[i, j])
                item = ExtendedTableWidgetItem(content)
                if '\n' in content:
                    item.original_value = content
                item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                table.setItem(i, j, item)
                if len(content) > 10:
                    item.setToolTip(content)

        table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        tab_layout.addWidget(table)
        self.tabs.addTab(tab_widget, sheet_name)

    def cell_content_changed(self, row, column):
        current_widget = self.tabs.currentWidget()
        if current_widget is not None:
            table = current_widget.layout().itemAt(0).widget()
            item = table.item(row, column)
            if item:
                table = current_widget.layout().itemAt(0).widget()
                self.last_edited_item = table.item(row, column)  # Keep track of the last edited item
                
    def update_sum_display(self):
        current_widget = self.tabs.currentWidget()
        if current_widget is not None:
            table = current_widget.layout().itemAt(0).widget()
            selected_items = table.selectedItems()
            total_sum = 0
            for item in selected_items:
                if hasattr(item, 'original_value') and item.original_value is not None:
                    values = item.original_value.split('\n')
                    try:
                        total_sum += sum(float(num.replace(',', '.')) for num in values if num.strip())
                    except ValueError:
                        pass 
                else:
                    try:
                        total_sum += float(item.text().replace(',', '.'))
                    except ValueError:
                        pass
                
        self.sum_label.setText(f"Kopā: {total_sum:.2f}")

    def search_tables(self):
        search_text = self.search_bar.text().lower()
        found_in_sheet = False

        for i in range(self.tabs.count()):
            tab_widget = self.tabs.widget(i)
            table = tab_widget.layout().itemAt(0).widget()
            sheet_has_match = False

            for row in range(table.rowCount()):
                row_visible = False
                for col in range(table.columnCount()):
                    item = table.item(row, col)
                    if item and search_text in item.text().lower():
                        row_visible = True
                        sheet_has_match = True
                        break
                table.setRowHidden(row, not row_visible)

            if sheet_has_match and not found_in_sheet:
                self.tabs.setCurrentIndex(i)
                found_in_sheet = True

            if not sheet_has_match:
                for row in range(table.rowCount()):
                    table.setRowHidden(row, False)

    def show_context_menu(self, position):
        table = self.sender()
        context_menu = QMenu(self)

        show_details_action = context_menu.addAction("Skatīt kopsavilkumu vai veikt labojumus")
        edit_cell_action = context_menu.addAction("Rediģēt šūnu")  # New action for editing the cell
        action = context_menu.exec_(table.viewport().mapToGlobal(position))

        if action == show_details_action:
            index = table.indexAt(position)
            if index.isValid():
                self.show_cell_details(index.row(), index.column(), table)
        elif action == edit_cell_action:  # Handle the edit cell action
            index = table.indexAt(position)
            if index.isValid():
                self.edit_cell(index.row(), index.column(), table)

    def edit_cell(self, row, column, table):
        item = table.item(row, column)  # Get the item at the specified row and column
        current_value = item.text()  # Use the text of the item as the current value
        sheet_name = self.tabs.tabText(self.tabs.currentIndex())
        df = self.dataFrames[sheet_name]

        new_value, ok = QInputDialog.getText(self, "Rediģēt šūnu", "Jaunā vērtība:", QLineEdit.Normal, current_value)

        if ok and new_value != current_value:
            # Update the cell in the table widget
            item.setText(new_value)

            # If the cell originally had multiple values, update the original_value attribute
            if hasattr(item, 'original_value') and item.original_value is not None:
                item.original_value = new_value

            # Update the cell in the DataFrame
            df.iloc[row, column] = new_value

            # Save changes to the Excel file
            self.save_excel_file()

#iespējams, šajā stadijā lieks
    def toggle_cell_editability(self, table, position):
        index = table.indexAt(position)
        if index.isValid():
            item = table.item(index.row(), index.column())
            if item:
                item.setFlags(item.flags() | Qt.ItemIsEditable)
                QTimer.singleShot(10, lambda: table.editItem(item))


    def show_cell_details(self, row, column, table):
        dialog = QDialog(self)
        dialog.setWindowTitle("Informācija par kriminālprocesu")
        dialog.resize(600, 600) 

        dialog_layout = QVBoxLayout()
        dialog.setLayout(dialog_layout)

        details_table = QTableWidget(table.columnCount(), 2)
        details_table.setHorizontalHeaderLabels(['Grupa', 'Vērtība'])
        details_table.verticalHeader().setVisible(False)
        details_table.setWordWrap(True)
        details_table.setEditTriggers(QTableWidget.DoubleClicked) #IZDZĒST??

        delegate = WordWrapDelegate()
        details_table.setItemDelegateForColumn(1, delegate)

        for col in range(table.columnCount()):
            header_item = QTableWidgetItem(table.horizontalHeaderItem(col).text())
            original_value = table.item(row, col).text() if table.item(row, col) is not None else ""

            value_item = QTableWidgetItem(original_value)
            details_table.setItem(col, 0, header_item)
            details_table.setItem(col, 1, value_item)

            value_item.setTextAlignment(Qt.AlignLeft | Qt.AlignTop)

            value_item.setTextAlignment(Qt.AlignLeft | Qt.AlignTop)
            value_item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsEditable)

        details_table.setColumnWidth(1, 450)
        dialog_layout.addWidget(details_table)
    
        def update_original():
            try:
                for col in range(details_table.rowCount()):
                    table_row = row
                    if table_row < len(self.row_mapping):
                        df_row = self.row_mapping[table_row]
                        if df_row < len(self.df) and col < len(self.df.columns):
                            original_item = table.item(table_row, col)
                            if original_item:
                                edited_value = details_table.item(col, 1).text()
                                original_item.setText(edited_value)
                                self.df.at[df_row, self.df.columns[col]] = edited_value
                        else:
                            print(f"DataFrame index out of range: df_row={df_row}, columns={len(self.df.columns)}")
                    else:
                        print(f"Row mapping index out of range: table_row={table_row}, row_mapping size={len(self.row_mapping)}")
                dialog.accept()
                self.save_excel_file()  # Save changes to the Excel file
            except Exception as e:
                print(f"Error updating original: {e}")
                dialog.reject()

        for i in range(details_table.rowCount()):
            details_table.resizeRowToContents(i)
            
        dialog.exec_()

    def save_excel_file(self):
        if not hasattr(self, 'currentFilePath') or not self.currentFilePath:
            QMessageBox.critical(self, "Error", "No file loaded or file path not set.")
            return

        try:
            with pd.ExcelWriter(self.currentFilePath, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
                for sheet_name, df in self.dataFrames.items():
                    df.to_excel(writer, sheet_name=sheet_name, index=False)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save file: {e}")

class CustomTableWidget(QTableWidget):
    def __init__(self, *args, **kwargs):
        super(CustomTableWidget, self).__init__(*args, **kwargs)
        self.editItemNextPress = None

    def mousePressEvent(self, event):
        super(CustomTableWidget, self).mousePressEvent(event)
        if event.button() == Qt.LeftButton and self.editItemNextPress is not None:
            self.editItem(self.editItemNextPress)
            self.editItemNextPress = None
        elif not self.indexAt(event.pos()).isValid():
            self.clearSelection()

    def mouseDoubleClickEvent(self, event):
        # Override to do nothing on double-click
        pass

def main():
    app = QApplication(sys.argv)
    from PyQt5.QtGui import QFont
    app.setFont(QFont("Cambria"))
    app.setStyleSheet("""
        QWidget {
            background-color: gray;
            color: black;
        }
        QTabWidget::pane {
            background-color: gray;
        }
        QTabBar {
            background-color: gray;
            color: black;
        }
    """)
    ex = ExcelDatabaseApp()
    ex.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()
